use crate::{
    node::SrcNode,
    ast::*
};
use rsh_common::{
    FunctionModifier,
    Literal,
    ScalarType,
    BinaryOp,
    UnaryOp,
    src::{Span, Loc},
    Ident,
};
use rsh_lexer::{Token, LexerError};
use naga::VectorSize;

// TODO: Error recovery

#[LALR]
grammar;

extern {
    type Location = Loc;
    type Error = LexerError;
    
    enum Token {
        "identifier" => Token::Identifier(<Ident>),
        "function modifier" => Token::FunctionModifier(<FunctionModifier>),

        "(" => Token::OpenParentheses,
        "{" => Token::OpenCurlyBraces,
        "[" => Token::OpenSquareBrackets,

        ")" => Token::CloseParentheses,
        "}" => Token::CloseCurlyBraces,
        "]" => Token::CloseSquareBrackets,

        "uint" => Token::Uint(<u64>),
        "int"=> Token::Int(<i64>),
        "float"=> Token::Float(<f64>),
        "bool"=> Token::Bool(<bool>),

        "2" => Token::Two,
        "3" => Token::Three,
        "4" => Token::Four,

        "scalar type" => Token::ScalarType(<ScalarType>),
        
        "global" => Token::Global,
        "const" => Token::Const,
        "fn" => Token::Fn,
        "Fn" => Token::FnTrait,
        "return" => Token::Return,
        "if" => Token::If,
        "else" => Token::Else,
        "let" => Token::Let,
        "struct" => Token::Struct,

        "Vector" => Token::Vector,
        "Matrix" => Token::Matrix,

        ":" => Token::Colon,
        "=" => Token::Equal,
        "->" => Token::Arrow,
        "," => Token::Comma,
        ";" => Token::SemiColon,
        "." => Token::Dot,
        ".." => Token::Dot2,

        "||" => Token::LogicalOr,
        "&&" => Token::LogicalAnd,

        "!=" => Token::Inequality,
        "==" => Token::Equality,
        ">" => Token::Greater,
        ">=" => Token::GreaterEqual,
        "<" => Token::Less,
        "<=" => Token::LessEqual,

        "|" => Token::BitWiseOr,
        "^" => Token::BitWiseXor,
        "&" => Token::BitWiseAnd,

        "+" => Token::Plus,
        "-" => Token::Minus,
        "/" => Token::Slash,
        "*" => Token::Star,
        "!" => Token::Bang,
        "%" => Token::Percent,

        "v2" => Token::V2,
        "v3" => Token::V3,
        "v4" => Token::V4,
        "m2" => Token::M2,
        "m3" => Token::M3,
        "m4" => Token::M4,

        "position" => Token::Position,
        "in" => Token::In,
        "out" => Token::Out,
        "uniform" => Token::Uniform,
        "set" => Token::Set,
        "binding" => Token::Binding
    }
}

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

CommaAtLeastOne<T>: Vec<T> = {
    <T> => vec![<>],
    <a: T> "," <mut v: Comma<T>> => {
        let mut tmp = vec![a];
        tmp.append(&mut v);
        tmp
    }
};

CommaAtLeastTwo<T>: Vec<T> = {
    <a: T> "," <b: T> => vec![a, b],
    <a: T> "," <b: T> "," <mut v: Comma<T>> => {
        let mut tmp = vec![a, b];
        tmp.append(&mut v);
        tmp
    }
}

#[inline]
SrcNode<Rule>: SrcNode<Rule> =
    <l: @L> <rule: Rule> <r: @R> =>
        SrcNode::new(rule, Span::range(l,r));

pub Program = SrcNode<Item>*;

Item: Item = {
    Struct => <>,

    "global" <modifier: SrcNode<GlobalModifier>> <ident: SrcNode<Ident>>
         <ty: (":" <SrcNode<Type>>)?> ";" 
             => Item::Global { <> },

    "fn" 
        <modifier: SrcNode<"function modifier">?>
        <ident: SrcNode<Ident>>
        <generics: SrcNode<Generics?>>
        <args: Args>
        <ret: SrcNode<Return>?>
        "{" <body: SrcNode<Block>> "}" => {
            let generics = generics.map_inner(|gen| match gen {
                Some(gen) => gen,
                None => Vec::new()
            });

            Item::Function { <> }
        },

    "const" <ident: SrcNode<Ident>> 
        ":" <ty: SrcNode<Type>> "=" <init: SrcNode<Expr>> ";"
        => Item::Const { <> }
}

Struct: Item = {
    "struct" <ident: SrcNode<Ident>> "{" <fields: CommaAtLeastOne<SrcNode<IdentTypePair>>> "}" 
            => Item::StructDef { <> },

    "struct" <ident: SrcNode<Ident>> "(" <fields: CommaAtLeastOne<SrcNode<Type>>> ")" ";"
            => {
                let fields = fields.into_iter().enumerate().map(|(pos,ty)| {
                    let span = ty.span();
                    
                    SrcNode::new(
                        IdentTypePair {
                            ident: SrcNode::new(
                                Ident::new(pos.to_string()),
                                Span::None
                            ),
                            ty
                        },
                        span
                    )
                }).collect();

                Item::StructDef { <> }
            },
}

Args = "(" <SrcNode<Comma<SrcNode<IdentTypePair>>>> ")";

Generics = "<" <CommaAtLeastOne<SrcNode<Generic>>> ">";

Generic: Generic = 
    <ident: SrcNode<Ident>> <bound: (":" <SrcNode<Trait>>)?> => Generic { <> };

IdentTypePair: IdentTypePair =
    <ident: SrcNode<Ident>> ":" <ty: SrcNode<Type>> => IdentTypePair { <> };

Return: Type = "->" <Type>;

Trait: TraitBound = {
    "Fn" "(" <args: SrcNode<Comma<SrcNode<Type>>>> ")" <ret: SrcNode<Return>?>
        => TraitBound::Fn { <> }
}

Type: Type = {
    <AtomType> => <>,
    "(" <AtomType> ")" => <>,
    TupleParser => <>
}

TupleParser: Type = "(" <CommaAtLeastTwo<SrcNode<Type>>> ")" => Type::Tuple(<>);

AtomType: Type = {
    "scalar type" => Type::ScalarType(<>),
    SrcNode<Ident> => Type::Named(<>),
    "Vector" "<" <VectorSize> "," <"scalar type"> ">"  => Type::Vector(<>),
    "Matrix" "<" <columns: VectorSize> "," <rows: VectorSize> ">" => Type::Matrix { <> },
}

VectorSize: VectorSize = {
    "2" => VectorSize::Bi,
    "3" => VectorSize::Tri,
    "4" => VectorSize::Quad,
}

Ident: Ident = {
    "identifier" => <>,
    "position" => Ident::new(String::from("position"))
}

GlobalModifier: GlobalModifier = {
    "position" => GlobalModifier::Position,
    "in" "=" <Location> => GlobalModifier::Input(<>),
    "out" "=" <Location> => GlobalModifier::Output(<>),
    "uniform" "{" 
        "set" "=" <set: Location>
        "binding" "=" <binding: Location>
    "}" => GlobalModifier::Uniform { <> }
}

Location: u32 = Uint => <> as u32;

Literal: Literal = {
    Uint => Literal::Uint(<>),
    "int" => Literal::Int(<>),
    "float" => Literal::Float(<>),
    "bool" => Literal::Boolean(<>),
}

Uint: u64 = {
    "2" => 2,
    "3" => 3,
    "4" => 4,
    "uint" => <>
}

Block: Vec<SrcNode<Statement>> = {
    <mut body: (<SrcNode<Stmt>> ";")*> <f: SrcNode<FinalStmt>?> => {
        if let Some(f) = f {
            body.push(f)
        }

        body
    },
}

Stmt: Statement = {
    <SrcNode<Expr>> => Statement::ExprSemi(<>),

    "let" <ident: SrcNode<Ident>> <ty: (":" <SrcNode<Type>>)?> "=" <init: SrcNode<Expr>>
        => Statement::Local { <> },

    <ident: SrcNode<Ident>> "=" <expr: SrcNode<Expr>>
        => Statement::Assignment { <> },
}

FinalStmt: Statement = SrcNode<Expr> => Statement::Expr(<>);

Tier<Op,NextTier>: Expression = {
    <left: SrcNode<Tier<Op,NextTier>>> 
        <op: SrcNode<Op>>
        <right: SrcNode<NextTier>>
            => Expression::BinaryOp { <> },

    NextTier
};

Expr: Expression = {
    "return" <SrcNode<Expr>?> => Expression::Return(<>),
    LogicalOr => <>
}

LogicalOr = Tier<LogicalOrOP, LogicalAnd>;
LogicalOrOP: BinaryOp = "||" => BinaryOp::LogicalOr;

LogicalAnd = Tier<LogicalAndOP, Equality>;
LogicalAndOP: BinaryOp = "&&" => BinaryOp::LogicalAnd;

Equality = Tier<EqualityOp, Comparison>;
EqualityOp: BinaryOp = {
    "==" => BinaryOp::Equality,
    "!=" => BinaryOp::Inequality,
}

Comparison = Tier<ComparisonOp, BitWiseOr>;
ComparisonOp: BinaryOp = {
    ">" => BinaryOp::Greater,
    ">=" => BinaryOp::GreaterEqual,
    "<" => BinaryOp::Less,
    "<=" => BinaryOp::LessEqual,
}

BitWiseOr = Tier<BitWiseOrOP, BitWiseXor>;
BitWiseOrOP: BinaryOp = "|" => BinaryOp::BitWiseOr;

BitWiseXor = Tier<BitWiseXorOP, BitWiseAnd>;
BitWiseXorOP: BinaryOp = "^" => BinaryOp::BitWiseXor;

BitWiseAnd = Tier<BitWiseAndOP, Additive>;
BitWiseAndOP: BinaryOp = "&" => BinaryOp::BitWiseAnd;

Additive = Tier<AdditiveOp, Multiplicative>;
AdditiveOp: BinaryOp = {
    "+" => BinaryOp::Addition,
    "-" => BinaryOp::Subtraction,
}

Multiplicative = Tier<MultiplicativeOp, Unary>;
MultiplicativeOp: BinaryOp = {
    "/" => BinaryOp::Division,
    "*" => BinaryOp::Multiplication,
    "%" => BinaryOp::Remainder,
}

Unary: Expression = {
    <op: SrcNode<UnaryOp>> <tgt: SrcNode<Unary>> => Expression::UnaryOp { <> },
    Index => <>
}

UnaryOp: UnaryOp = {
    "!" => UnaryOp::BitWiseNot,
    "-" => UnaryOp::Negation
}

// TODO: Add range support
Index: Expression = {
    <base: SrcNode<Index>> "[" <index: SrcNode<Expr>> "]" => Expression::Index { <> },
    StructAccess => <>
}

StructAccess: Expression = {
    <base: SrcNode<StructAccess>> "." <field: SrcNode<Field>>
        => Expression::Access { <> },
    Call => <>
}
Field: Ident = {
    Ident => <>,
    Uint => Ident::new(<>.to_string())
}

Call: Expression = {
    <fun: SrcNode<Call>> "(" <args: SrcNode<Comma<SrcNode<Expr>>>> ")"
        => Expression::Call { <> },
    Atom => <>
}

Atom: Expression = {
    Literal => Expression::Literal(<>),
    "(" <CommaAtLeastTwo<SrcNode<Expr>>> ")" => Expression::TupleConstructor(<>),
    "(" <Expr> ")" => <>,
    <ty: Constructor> "(" <elements: SrcNode<CommaAtLeastOne<SrcNode<Expr>>>> ")" 
        => Expression::Constructor {
            ty: ty.0,
            size: ty.1,
            elements
        },
    SrcNode<Ident> => Expression::Variable(<>),
    If => <>
}

If: Expression = 
    "if" <condition: SrcNode<Expr>> "{"
        <accept: SrcNode<Block>>
    "}" <else_ifs: ElseIf*> <reject: Else?>
        => Expression::If { <> };

ElseIf: (SrcNode<Expression>, SrcNode<Block>) =
    "else" "if" <SrcNode<Expr>> "{" <SrcNode<Block>> "}" => (<>);

Else: SrcNode<Block> =
    "else" "{" <SrcNode<Block>> "}" => <>;

Constructor: (ConstructorType, VectorSize) = {
    "v2" => (ConstructorType::Vector, VectorSize::Bi),
    "v3" => (ConstructorType::Vector, VectorSize::Tri),
    "v4" => (ConstructorType::Vector, VectorSize::Quad),
    "m2" => (ConstructorType::Matrix, VectorSize::Bi),
    "m3" => (ConstructorType::Matrix, VectorSize::Tri),
    "m4" => (ConstructorType::Matrix, VectorSize::Quad),
}